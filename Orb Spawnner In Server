-- Orb Collector System - Single Script
-- Runs as a ServerScript in ServerScriptService
-- Demonstrates CFrame math, physics, metatables, services, raycasting, tweens, events.

local OrbManager = {} -- table placeholder for the orb manager (defined later)

-- // Service references
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace") -- main 3D world

-- // RemoteEvents setup (for client communication)
local remFolder = Instance.new("Folder")
remFolder.Name = "OrbRemotes"
remFolder.Parent = ReplicatedStorage

local RemoteEvent_PlayerCollected = Instance.new("RemoteEvent") -- remote to notify when player collects an orb
RemoteEvent_PlayerCollected.Name = "PlayerCollected"
RemoteEvent_PlayerCollected.Parent = remFolder

local RemoteEvent_OrbSpawned = Instance.new("RemoteEvent") -- remote to notify when a new orb spawns
RemoteEvent_OrbSpawned.Name = "OrbSpawned"
RemoteEvent_OrbSpawned.Parent = remFolder

-- // Configuration table (adjust gameplay here)
local CONFIG = {
	OrbModelName = "CollectOrb", -- name for orb model
	SpawnInterval = 6, -- seconds between spawn attempts
	MaxOrbs = 12, -- maximum number of orbs at once
	OrbLifetime = 35, -- seconds before orb cleanup
	AttractionRadius = 12, -- range where orbs start moving toward player
	AttractionForce = 60, -- how strongly orbs pull toward the player
	PointsPerOrb = 10, -- points per orb collected
	SpawnArea = { -- defines the center and size of spawn area
		Center = Vector3.new(0, 5, 0),
		Size = Vector3.new(80, 15, 80)
	},
}

-- // Utility function: returns a random Vector3 within a defined box area
local function randomPointWithin(center, size)
	local x = center.X + (math.random() - 0.5) * size.X -- random offset in X
	local y = center.Y + (math.random() - 0.5) * size.Y -- random offset in Y
	local z = center.Z + (math.random() - 0.5) * size.Z -- random offset in Z
	return Vector3.new(x,y,z) -- return as Vector3
end

-- // Debug print toggle function
local function debugPrint(...)
	if false then -- change to true to enable debug output
		print(...)
	end
end

-- // Simple OOP (class) helper using metatables
local function class(template)
	template = template or {}
	template.__index = template
	function template:new(o)
		o = o or {}
		setmetatable(o, self)
		if o.init then o:init() end
		return o
	end
	return template
end

-- // Orb class (each orb is its own object)
local Orb = class()

function Orb:init()
	-- Create visual and physical part
	local model = Instance.new("Part")
	model.Shape = Enum.PartType.Ball
	model.Material = Enum.Material.Neon
	model.Anchored = false
	model.CanCollide = false
	model.Size = Vector3.new(1.2,1.2,1.2)
	model.CFrame = CFrame.new(self.position)
	model.Name = "Orb"
	model.Parent = Workspace 

	-- Light for glow effect
	local light = Instance.new("PointLight")
	light.Range = 12
	light.Brightness = 2
	light.Parent = model

	-- Small spawn sound
	local s = Instance.new("Sound")
	s.SoundId = "rbxassetid://1843529260" -- sound asset ID
	s.Volume = 0.6
	s.Parent = model
	s:Play() -- play immediately

	-- BodyVelocity for motion control
	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(1e5, 1e5, 1e5) -- allow strong movement
	bv.Velocity = Vector3.new(0,0,0) -- start still
	bv.Parent = model

	-- Tag for tracking
	CollectionService:AddTag(model, "OrbTag")

	self.instance = model -- store reference
	self.bodyVelocity = bv
	self.spawnTick = tick() -- record spawn time
	self.collected = false -- flag to check if already collected

	-- Oscillator for gentle floating motion
	self.oscillator = {
		speed = 2 + math.random() * 1.5, -- wave speed
		magnitude = 0.35 + math.random() * 0.65, -- amplitude
		phase = math.random() * math.pi * 2, -- random phase offset
	}

	-- Auto cleanup after lifespan
	Debris:AddItem(model, CONFIG.OrbLifetime + 2)
end

-- Update function, runs every frame
function Orb:update(dt)
	if self.collected then return end -- skip if already collected
	if not self.instance or not self.instance.Parent then return end -- skip if deleted

	-- Oscillate vertically (float animation)
	local t = (tick() - self.spawnTick)
	local dy = math.sin(t * self.oscillator.speed + self.oscillator.phase) * self.oscillator.magnitude
	local base = self.instance.Position
	local targetY = base.Y + dy
	local targetPos = Vector3.new(base.X, targetY, base.Z)
	local desired = (targetPos - self.instance.Position) * 12
	self.bodyVelocity.Velocity = Vector3.new(desired.X, desired.Y, desired.Z) -- apply float motion

	-- Attraction logic: pull orb toward nearby players
	local nearPlayer = OrbManager:findNearestPlayer(self.instance.Position, CONFIG.AttractionRadius)
	if nearPlayer then -- if player found
		local humanoidRoot = nearPlayer.Character and nearPlayer.Character:FindFirstChild("HumanoidRootPart")
		if humanoidRoot then
			local dir = (humanoidRoot.Position - self.instance.Position) -- direction vector
			local dist = dir.Magnitude -- distance between orb and player
			local force = math.clamp((CONFIG.AttractionRadius - dist) / CONFIG.AttractionRadius, 0, 1) * CONFIG.AttractionForce
			local vel = dir.Unit * force -- scaled velocity
			self.bodyVelocity.Velocity = self.bodyVelocity.Velocity + vel -- apply pull
			if dist < 2.2 then -- if close enough, collect
				OrbManager:collectOrb(self, nearPlayer)
			end
		end
	end
end

-- Safely destroy orb
function Orb:destroy()
	if not self.instance then return end
	pcall(function()
		CollectionService:RemoveTag(self.instance, "OrbTag")
		self.instance:Destroy()
	end)
	self.instance = nil
end

-- // Orb Manager (handles all orbs globally)
local OrbManager = class({ orbs = {}, playersScore = {} })

function OrbManager:init()
	self.orbs = {} -- list of all active orbs
	self.spawnAccumulator = 0 -- time counter for spawns
	self.lastSpawn = 0
	self.maxOrbs = CONFIG.MaxOrbs
end

-- Spawns a new orb at position
function OrbManager:spawnOrb(pos)
	if #self.orbs >= self.maxOrbs then return nil end -- don’t exceed limit
	local orb = Orb:new({ position = pos }) -- create orb instance
	table.insert(self.orbs, orb)
	RemoteEvent_OrbSpawned:FireAllClients(orb.instance.Position) -- tell clients
	return orb
end

-- Handles player collecting orb
function OrbManager:collectOrb(orb, player)
	if orb.collected then return end
	orb.collected = true
	local pid = player.UserId
	self.playersScore[pid] = (self.playersScore[pid] or 0) + CONFIG.PointsPerOrb -- add points

	-- Play collect sound
	if orb.instance and orb.instance.Parent then
		local s = Instance.new("Sound")
		s.SoundId = "rbxassetid://1843529838"
		s.Parent = orb.instance
		s:Play()
	end
	RemoteEvent_PlayerCollected:FireClient(player, CONFIG.PointsPerOrb, orb.instance.Position)

	-- Tween shrink + fade effect
	if orb.instance then
		local tw = TweenService:Create(
			orb.instance,
			TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{Size = Vector3.new(0.4,0.4,0.4), Transparency = 1}
		)
		tw:Play()
		tw.Completed:Wait()
	end

	orb:destroy() -- cleanup
	for i,v in ipairs(self.orbs) do -- remove from active list
		if v == orb then
			table.remove(self.orbs, i)
			break
		end
	end
end

-- Finds the closest player to a point within a radius
function OrbManager:findNearestPlayer(position, radius)
	local nearest = nil
	local nd = radius
	for _,p in pairs(Players:GetPlayers()) do
		if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = p.Character.HumanoidRootPart
			local d = (hrp.Position - position).Magnitude
			if d < nd then
				nd = d
				nearest = p
			end
		end
	end
	return nearest
end

-- Removes invalid orbs from list
function OrbManager:cleanupOrbs()
	for i = #self.orbs,1,-1 do
		local o = self.orbs[i]
		if not o.instance or not o.instance.Parent then
			table.remove(self.orbs, i)
		end
	end
end

-- Controls spawning based on timer
function OrbManager:spawnTick(dt)
	self.spawnAccumulator = self.spawnAccumulator + dt
	if self.spawnAccumulator >= CONFIG.SpawnInterval then
		self.spawnAccumulator = 0
		local attempts = 0
		while #self.orbs < self.maxOrbs and attempts < 6 do
			attempts = attempts + 1
			local pos = randomPointWithin(CONFIG.SpawnArea.Center, CONFIG.SpawnArea.Size)
			local rayOrigin = pos + Vector3.new(0, 50, 0)
			local rayDir = Vector3.new(0, -120, 0)
			local raycastParams = RaycastParams.new()
			raycastParams.FilterDescendantsInstances = {}
			raycastParams.FilterType = Enum.RaycastFilterType.Exclude
			raycastParams.IgnoreWater = true
			local res = Workspace:Raycast(rayOrigin, rayDir, raycastParams)
			if res then
				local groundPos = res.Position + Vector3.new(0, 2, 0)
				self:spawnOrb(groundPos)
			end
		end
	end
end

-- Ensures player has a leaderstats scoreboard
local function ensureLeaderstats(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
	end
	local score = leaderstats:FindFirstChild("Orbs")
	if not score then
		score = Instance.new("IntValue")
		score.Name = "Orbs"
		score.Value = OrbManager.playersScore[player.UserId] or 0
		score.Parent = leaderstats
	end
	return score
end

-- // Player connections
Players.PlayerAdded:Connect(function(player)
	OrbManager.playersScore[player.UserId] = OrbManager.playersScore[player.UserId] or 0
	ensureLeaderstats(player)

	player.CharacterAdded:Connect(function(char)
		local hrp = char:WaitForChild("HumanoidRootPart", 5)
		if hrp then
			local b = Instance.new("BodyVelocity")
			b.MaxForce = Vector3.new(5e4,5e4,5e4)
			b.Velocity = Vector3.new((math.random()-0.5)*12, 0, (math.random()-0.5)*12)
			b.Parent = hrp
			Debris:AddItem(b, 0.35)
		end
	end)

	-- client feedback remote (server doesn’t trust input)
	RemoteEvent_PlayerCollected.OnServerEvent:Connect(function(from, points, pos)
		-- do nothing (server authoritative)
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	-- keep score in memory for reconnect
end)

-- Initialize system
OrbManager:init()

-- // Main loop using RunService Heartbeat
local accumulated = 0
RunService.Heartbeat:Connect(function(dt)
	accumulated = accumulated + dt
	for i,orb in ipairs(OrbManager.orbs) do
		pcall(function()
			orb:update(dt)
		end)
	end
	OrbManager:spawnTick(dt)
	OrbManager:cleanupOrbs()

	-- update leaderstats every ~2 seconds
	if math.floor(tick()) % 2 == 0 then
		for _,p in pairs(Players:GetPlayers()) do
			local ls = p:FindFirstChild("leaderstats")
			if ls and ls:FindFirstChild("Orbs") then
				ls.Orbs.Value = OrbManager.playersScore[p.UserId] or ls.Orbs.Value
			end
		end
	end
end)

-- // Admin helper to manually spawn 3 orbs
local function adminSpawn(pos)
	if typeof(pos) ~= "Vector3" then
		pos = CONFIG.SpawnArea.Center
	end
	for i=1,3 do
		OrbManager:spawnOrb(pos + Vector3.new(math.random(-4,4), math.random(0,4), math.random(-4,4)))
	end
end

-- // Public API for other scripts
local API = {}
API.spawnOrbAt = function(position)
	return OrbManager:spawnOrb(position)
end
API.getScores = function()
	return OrbManager.playersScore
end
API.forceSpawn = adminSpawn

_G.OrbCollectorAPI = API -- expose globally (for quick debugging, not production)

print("OrbCollector script initialized. MaxOrbs=", CONFIG.MaxOrbs) -- confirmation log

-- End of script
